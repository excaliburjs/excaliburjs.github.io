{"componentChunkName":"component---src-templates-docs-page-template-js-content-file-path-docs-03-actors-mdx","path":"/docs/actors/","result":{"data":{"github":{"data":{"repository":{"releases":{"edges":[{"node":{"publishedAt":"2023-12-02T02:40:30Z","name":"Excalibur v0.28.2 Release","tag":{"name":"v0.28.2"}}},{"node":{"publishedAt":"2023-08-11T01:36:42Z","name":"Excalibur v0.28.0 Release","tag":{"name":"v0.28.0"}}},{"node":{"publishedAt":"2022-07-09T01:19:28Z","name":"Excalibur v0.27.0 Release","tag":{"name":"v0.27.0"}}},{"node":{"publishedAt":"2022-05-21T00:49:41Z","name":"Excalibur v0.26.0 Release","tag":{"name":"v0.26.0"}}},{"node":{"publishedAt":"2022-02-05T23:53:33Z","name":"Excalibur v0.25.3 Release","tag":{"name":"v0.25.3"}}}]}}}},"toc":{"edges":[{"node":{"id":"dad98d07-474c-5672-9dc6-0347e90c6793","frontmatter":{"title":"Welcome","path":"/docs/","section":"Introduction"}}},{"node":{"id":"da624576-bb5a-579b-8759-02496b34e40a","frontmatter":{"title":"Excalibur's Philosophy","path":"/docs/goals","section":"Introduction"}}},{"node":{"id":"2e771808-9321-55e9-af67-192e7aa572e7","frontmatter":{"title":"Installation Guide","path":"/docs/installation","section":"Getting Started"}}},{"node":{"id":"7000635a-aee7-58a5-888d-0046f878975f","frontmatter":{"title":"Getting Started","path":"/docs/getting-started","section":"Getting Started"}}},{"node":{"id":"7e381e47-34bf-5983-8f8a-23cf08fa51a4","frontmatter":{"title":"Build & Bundlers","path":"/docs/bundlers","section":"Getting Started"}}},{"node":{"id":"d76a770e-ba1f-523e-b91e-20478205d36b","frontmatter":{"title":"Actors","path":"/docs/actors","section":"Fundamentals"}}},{"node":{"id":"abda6651-2a20-5771-acf5-75df1b002eb8","frontmatter":{"title":"Engine Fundamentals","path":"/docs/engine","section":"Fundamentals"}}},{"node":{"id":"485c6dcb-8eca-54a2-8b93-c588d83b2de5","frontmatter":{"title":"Cameras","path":"/docs/cameras","section":"Fundamentals"}}},{"node":{"id":"81077a63-24bb-5c0c-b824-e67b0327184c","frontmatter":{"title":"Scenes","path":"/docs/scenes","section":"Fundamentals"}}},{"node":{"id":"50cfedc7-12ae-5b69-87f1-bbeb5ba25a1c","frontmatter":{"title":"DisplayModes","path":"/docs/displaymodes","section":"Screen & Viewport"}}},{"node":{"id":"41945ef9-20a8-57a2-a98f-8c65910a4146","frontmatter":{"title":"Screen & Viewport","path":"/docs/screens","section":"Screen & Viewport"}}},{"node":{"id":"d3d0686a-208c-5965-a7fe-bdd370ec06b9","frontmatter":{"title":"Color","path":"/docs/color","section":"Graphics"}}},{"node":{"id":"8e8a130d-da7f-52bd-9f5b-edca962a2e43","frontmatter":{"title":"Graphics","path":"/docs/graphics","section":"Graphics"}}},{"node":{"id":"2711c428-18f5-5a66-833a-b952df2e1a7e","frontmatter":{"title":"Lines","path":"/docs/lines","section":"Graphics"}}},{"node":{"id":"08e17b5e-202e-56d4-950b-09ace0312d74","frontmatter":{"title":"Sprites","path":"/docs/sprites","section":"Graphics"}}},{"node":{"id":"857b3684-3e57-5975-879e-ae2270543839","frontmatter":{"title":"Spritesheets","path":"/docs/spritesheets","section":"Graphics"}}},{"node":{"id":"fcf36edc-32a3-57aa-ad00-391494f7766b","frontmatter":{"title":"Text & Fonts","path":"/docs/text","section":"Graphics"}}},{"node":{"id":"91be0486-77db-5548-ab44-fd6e02d73284","frontmatter":{"title":"Animation","path":"/docs/animation","section":"Graphics"}}},{"node":{"id":"9c76d3f3-5289-5d6b-a176-1f346d2e621b","frontmatter":{"title":"Canvas","path":"/docs/canvas","section":"Graphics"}}},{"node":{"id":"a69a38dd-0055-5d88-abf7-43f8b7062d4c","frontmatter":{"title":"Graphics Component","path":"/docs/graphics-component","section":"Graphics"}}},{"node":{"id":"a01c37b7-e332-5c7e-b4d8-de9bd992ec43","frontmatter":{"title":"Graphics Group","path":"/docs/graphics-group","section":"Graphics"}}},{"node":{"id":"eb15a261-5762-51d2-97f1-9cf4b32c9693","frontmatter":{"title":"Material","path":"/docs/material","section":"Graphics"}}},{"node":{"id":"fbe8508e-5a7e-57bc-a029-f07acedfd969","frontmatter":{"title":"Graphics Context","path":"/docs/graphics-context","section":"Graphics"}}},{"node":{"id":"bf6363fc-32f2-5161-a842-dec6b9c8934c","frontmatter":{"title":"Parallax","path":"/docs/parallax","section":"Graphics"}}},{"node":{"id":"f1efbb7b-69f5-5f8f-9391-21b21f9598cd","frontmatter":{"title":"ECS","path":"/docs/entity-component-system","section":"Entity Component System"}}},{"node":{"id":"cafde7bd-f517-5362-95ec-6b4bf7ca80bb","frontmatter":{"title":"ImageSource","path":"/docs/imagesource","section":"Resources"}}},{"node":{"id":"a0f02255-f693-5966-844b-4b5cb567a231","frontmatter":{"title":"Loader","path":"/docs/loader","section":"Resources"}}},{"node":{"id":"53e76878-d0d8-55ef-9f8a-7bb0a50a5fe2","frontmatter":{"title":"Sound","path":"/docs/sound","section":"Resources"}}},{"node":{"id":"7c26d3e6-ced4-529f-9ae8-95a9c18965a7","frontmatter":{"title":"Entities","path":"/docs/entities","section":"Entity Component System"}}},{"node":{"id":"95d94e6c-6505-5c46-92c2-d0fd2796c66d","frontmatter":{"title":"Components","path":"/docs/components","section":"Entity Component System"}}},{"node":{"id":"407163b4-4a21-591c-8268-32feb2794249","frontmatter":{"title":"Systems","path":"/docs/systems","section":"Entity Component System"}}},{"node":{"id":"5b732b02-0afa-532b-971b-7b81950067c0","frontmatter":{"title":"Queries","path":"/docs/queries","section":"Entity Component System"}}},{"node":{"id":"f95325ef-9ad4-5e99-a69d-c00f14774b76","frontmatter":{"title":"Actions","path":"/docs/actions","section":"Actions"}}},{"node":{"id":"f27b1e7d-dccc-5f6b-9ee9-12c92799a241","frontmatter":{"title":"Blink","path":"/docs/actions-blink","section":"Actions"}}},{"node":{"id":"3245878c-014c-5ab9-be83-3e515eff5937","frontmatter":{"title":"CallMethod","path":"/docs/actions-callmethod","section":"Actions"}}},{"node":{"id":"ab4d5e09-8c48-522a-9417-436fd08502f6","frontmatter":{"title":"Parallel Actions","path":"/docs/actions-parallel","section":"Actions"}}},{"node":{"id":"2c8793b5-2707-5118-9c0a-506a8f4ddb49","frontmatter":{"title":"Delay","path":"/docs/actions-delay","section":"Actions"}}},{"node":{"id":"b9211092-cfae-59bc-93cf-8aaf1efc24b8","frontmatter":{"title":"EaseTo","path":"/docs/actions-ease","section":"Actions"}}},{"node":{"id":"8e050c66-f7d6-5f19-a8f8-f9d5ccb40a3a","frontmatter":{"title":"MoveTo/MoveBy","path":"/docs/actions-move","section":"Actions"}}},{"node":{"id":"8b3ef123-400d-53a7-9488-b70bba3d0990","frontmatter":{"title":"Fade","path":"/docs/actions-fade","section":"Actions"}}},{"node":{"id":"2d3f2cfb-4119-59ca-8b96-a3b8f097ba43","frontmatter":{"title":"RotateTo/RotateBy","path":"/docs/actions-rotate","section":"Actions"}}},{"node":{"id":"5f7f0cfe-b384-5ecd-8d8b-885762a265c6","frontmatter":{"title":"Repeat","path":"/docs/actions-repeat","section":"Actions"}}},{"node":{"id":"00220f48-0a05-5a8c-99dc-ed6f4772418f","frontmatter":{"title":"Die","path":"/docs/actions-die","section":"Actions"}}},{"node":{"id":"70540dde-8d21-5198-ba4c-c8bc86bffc54","frontmatter":{"title":"Follow","path":"/docs/actions-follow","section":"Actions"}}},{"node":{"id":"1adf281e-d968-5d03-b8e7-8f71391ddfe5","frontmatter":{"title":"Meet","path":"/docs/actions-meet","section":"Actions"}}},{"node":{"id":"6a0b5de9-211f-52d0-90c8-7126e4859ddf","frontmatter":{"title":"ScaleTo/ScaleBy","path":"/docs/actions-scale","section":"Actions"}}},{"node":{"id":"8245c2c2-3dda-5161-8a63-b8a7e34d9c8d","frontmatter":{"title":"Isometric TileMaps","path":"/docs/isometric","section":"TileMaps"}}},{"node":{"id":"ddb7a109-235b-5575-9a8c-5b0fde25f72b","frontmatter":{"title":"Matrix","path":"/docs/matrix","section":"Math"}}},{"node":{"id":"b9a32410-4aaa-592c-903b-f93aa5b86f20","frontmatter":{"title":"Random","path":"/docs/random","section":"Math"}}},{"node":{"id":"c33af30d-0492-5a02-9609-edb273218a8d","frontmatter":{"title":"Ray","path":"/docs/ray","section":"Math"}}},{"node":{"id":"a0b255f8-1cc0-5b77-9e64-0ece28897ce9","frontmatter":{"title":"TileMap","path":"/docs/tilemap","section":"TileMaps"}}},{"node":{"id":"4c417240-3f88-53ba-99e1-025121496738","frontmatter":{"title":"Vector","path":"/docs/vector","section":"Math"}}},{"node":{"id":"4f5f05f5-5f3f-5a16-a3b3-ab1dd405429a","frontmatter":{"title":"Physics","path":"/docs/physics","section":"Physics"}}},{"node":{"id":"fd65067f-eb2d-58bd-8bef-2e3f34e3050a","frontmatter":{"title":"Fixed Update","path":"/docs/fixed-update","section":"Physics"}}},{"node":{"id":"35f3f730-c264-51c9-a873-f4f818cc7559","frontmatter":{"title":"Bodies","path":"/docs/bodies","section":"Physics"}}},{"node":{"id":"e79b1c68-d688-587d-a190-ffb310ad3b97","frontmatter":{"title":"Colliders","path":"/docs/colliders","section":"Physics"}}},{"node":{"id":"38a5696d-430d-57d2-9e58-c3887e365415","frontmatter":{"title":"Collision Events","path":"/docs/collision-events","section":"Physics"}}},{"node":{"id":"0735bbe6-3d12-5f87-bb6d-1433223fed6c","frontmatter":{"title":"Collision Groups","path":"/docs/collisiongroups","section":"Physics"}}},{"node":{"id":"ac835bf3-7993-5495-ad2c-a80a3051bce4","frontmatter":{"title":"Collision Types","path":"/docs/collisiontypes","section":"Physics"}}},{"node":{"id":"2114efbb-02cb-5c57-b9e9-d1cb1306d433","frontmatter":{"title":"Ray Casting","path":"/docs/raycast","section":"Physics"}}},{"node":{"id":"b67a6f9e-f390-5469-9653-1fc75298cd06","frontmatter":{"title":"Input","path":"/docs/input","section":"Input"}}},{"node":{"id":"5f547a14-ebaf-576d-bff0-1cc04f5173c7","frontmatter":{"title":"Keyboard","path":"/docs/keyboard","section":"Input"}}},{"node":{"id":"8e683857-b44d-5d10-8e83-facf24a8e7c0","frontmatter":{"title":"Pointers","path":"/docs/pointers","section":"Input"}}},{"node":{"id":"5286dacc-f819-5aba-b761-713e3e649064","frontmatter":{"title":"Gamepad","path":"/docs/gamepad","section":"Input"}}},{"node":{"id":"f779f9a5-0576-5c95-bc23-b2b6377355d8","frontmatter":{"title":"Input Mapper","path":"/docs/input-mapper","section":"Input"}}},{"node":{"id":"8a130edb-7ac8-58f6-a2e4-344eb37c2bb8","frontmatter":{"title":"Migration","path":"/docs/migration","section":"Migration Guides"}}},{"node":{"id":"75de5b14-9428-5a4d-9e05-186af96b5456","frontmatter":{"title":"Debugging Tips","path":"/docs/debugging","section":"Other"}}},{"node":{"id":"b8312b83-f50b-5e03-a0ef-fcfe2d88027f","frontmatter":{"title":"Events","path":"/docs/events","section":"Other"}}},{"node":{"id":"a1aeaced-120d-570b-a141-6476312651fb","frontmatter":{"title":"Patterns","path":"/docs/patterns","section":"Other"}}},{"node":{"id":"783792ad-d1cc-5d0e-a737-e73512ab6a0b","frontmatter":{"title":"Timers","path":"/docs/timers","section":"Other"}}},{"node":{"id":"cfb9538b-f7f0-501c-9c10-e037005325d1","frontmatter":{"title":"Triggers","path":"/docs/triggers","section":"Other"}}},{"node":{"id":"01ad41f7-cf7e-55ad-9930-e4d08edaa8ed","frontmatter":{"title":"Clock","path":"/docs/clock","section":"Fundamentals"}}},{"node":{"id":"aa75522b-40c9-580f-adf0-e71e31fccd5a","frontmatter":{"title":"PostProcessors","path":"/docs/postprocessors","section":"Graphics"}}},{"node":{"id":"1ab8bc77-ef47-519a-85c9-ec04a252e70f","frontmatter":{"title":"UI","path":"/docs/ui","section":"Other"}}},{"node":{"id":"b16467e8-8826-56b8-b6b9-41dfc0d20763","frontmatter":{"title":"Particles","path":"/docs/particles","section":"Other"}}},{"node":{"id":"28a19bd1-1999-5b75-8935-540870ed3958","frontmatter":{"title":"Performance","path":"/docs/performance","section":"Other"}}},{"node":{"id":"f6a67a64-82f9-55dd-a25c-2918f73e5fa3","frontmatter":{"title":"Aseprite plugin","path":"/docs/aseprite-plugin","section":"Plugins"}}},{"node":{"id":"0e0956e2-d260-53c9-84fc-dde778da48d8","frontmatter":{"title":"Tiled Plugin","path":"/docs/tiled-plugin","section":"Plugins"}}},{"node":{"id":"61e82f66-9054-587d-a796-318af9ed99de","frontmatter":{"title":"Dev Tool","path":"/docs/devtool","section":"Plugins"}}},{"node":{"id":"425459c5-fbe5-5e57-b70f-32397e00d3fc","frontmatter":{"title":"Hosting Excalibur Games","path":"/docs/hosting","section":"Other"}}},{"node":{"id":"87b07ea3-8d34-5617-b0d1-7aeffdf0094b","frontmatter":{"title":"Custom Renderer Plugins","path":"/docs/custom-renderer-plugins","section":"Graphics"}}},{"node":{"id":"ed65a418-625a-5a66-b2b2-55ebccb2f1d0","frontmatter":{"title":"Utilities","path":"/docs/utilities","section":"Other"}}}]},"page":{"body":"\n[[Actor|Actors]] are prebuilt Excalibur [[Entity|Entities]] that come with the batteries included for most applications.\nLike [[TransformComponent|position]], [[MotionComponent|velocity]], [[GraphicsComponent|graphics]], and [[ColliderComponent|collision detection]].\n\n[[Actor|Actors]] are the recommended way to use Excalibur, they are the primary way to show something on the screen.\n\nIf you don't want these built-ins and you want to build only what you want, read about entities [here](/docs/entities)\n\n## Basic actors\n\nFor quick and dirty games, you can just create an instance of an [[Actor]]\nand manipulate it directly.\n\nActors (and other entities) must be added to a [Scene](/docs/scene) to be drawn\nand updated on-screen.\n\n`embed:excalibur-snippets/src/actor/main.ts{snippet: \"actor\"}`\n\n<IFrameEmbed src=\"https://excaliburjs.com/excalibur-snippets/actor/\" />\n\n[[Engine.add|game.add]] is a convenience method for adding an actor to the current scene. The equivalent verbose call is [[Scene.add|game.currentScene.add]].\n\n## Custom actors\n\nFor \"real-world\" games, it is common to extend the `Actor` class.\nThis gives you much greater control and encapsulates logic for that\nactor. This is optional, but is nice for encapsulating your specifics.\n\n```ts\nclass Player extends ex.Actor {\n  public health: number = 100\n  public ammo: number = 20\n\n  constructor() {\n    super({ x: 10, y: 10 })\n  }\n\n  shoot() {\n    if (this.ammo < 1) {\n      return\n    }\n\n    this.ammo -= 1\n  }\n}\n```\n\nCustom actors make it easier to hook into the actor lifecycle and encapsulate the actor's state better than a basic actor.\n\n## Actor lifecycle\n\nAn actor has a basic lifecycle that dictates how it is initialized, updated, and drawn. Once an actor is part of a\n[scene](/docs/scene), it will follow this lifecycle.\n\n![Actor Lifecycle](/assets/images/docs/ActorLifecycle.png)\n\n## Updating actors\n\nIn most games, things are happening on screen: the background is parallaxing, your hero responds to input, or enemies shoot bullets. In Excalibur, the logic that updates game state is run during the [update loop](/docs/engine#engine-lifecycle). Actors are a way to encapsulate that logic, such as a `Player` or `Enemy` or `MenuButton`. Actors can be pretty much anything!\n\n### Initialization\n\nYou should override the [[Actor.onInitialize]] method to perform any startup logic\nfor an actor (such as configuring state). `onInitialize` gets called\n**once** before the first frame an actor is drawn/updated. It is passed\nan instance of [Engine](/docs/engine) to access global state or perform coordinate math.\n\n<Note>\n\nThis is the recommended way to manage startup logic for actor, _not_ the constructor since\nyou don't incur the cost of initialization until an actor is ready to be updated in the game.\n\n</Note>\n\n```ts\nclass Player extends ex.Actor {\n  public level = 1\n  public endurance = 0\n  public fortitude = 0\n\n  constructor() {\n    super({ x: 50, y: 50 })\n  }\n\n  public onInitialize(engine: ex.Engine) {\n    this.endurance = 20\n    this.fortitude = 16\n  }\n\n  public getMaxHealth() {\n    return 0.4 * this.endurance + 0.9 * this.fortitude + this.level * 1.2\n  }\n}\n```\n\nThere are three ways to hook into the update loop of an actor: [[Actor.onPreUpdate]], [[Actor.update]] and [[Actor.onPostUpdate]]. Actors (and other entities in Excalibur) all have \"core\" logic that runs in the update or draw loop. The pre- and post-method hooks allow you to choose when you want to run logic in each phase. _Normally_ you will run logic in the \"post\" hook but sometimes you may want to completely override the core logic or run logic that uses state that was updated _before_ the core logic runs.\n\nAll update methods are passed an instance of the Excalibur engine, which\ncan be used to perform coordinate math or access global state. It is also\npassed `delta` which is the time in milliseconds since the last frame, which can be used\nto perform time-based movement or time-based math (such as a [timer](/docs/utilities)).\n\n<Note>\n\nReference [Actor lifecycle](#actor-lifecycle) for a breakdown of each phase and when things are executed.\n\n</Note>\n\n### Update\n\nYou can override the core [[Actor.update]] but it is important to call the `super.update(...)` method in order to preserve the Excalibur core update implementation.\n\n```typescript\nclass Player extends Actor {\n  public update(engine: Engine, delta: number) {\n    // Custom update here\n    super.update(engine, delta)\n    // Custom update here\n  }\n}\n```\n\n<Note variant=\"warning\">\n\nActions will not function properly if you override `Actor.update()` without calling the `super.update()`\n\n</Note>\n\n### Pre-update\n\nOverride the [[Actor.onPreUpdate]] method to update the state of your actor before [[Actor.update]].\n\n<Note>\n\n**Important:** This logic will run _before_ the core Excalibur update logic runs, so you may not have the latest transform matrix applied or other positional information updated. Essentially you will be working with the _last frame's state_.\n\n</Note>\n\n```ts\nclass Player extends Actor {\n  /**\n   * Runs before \"core\" update logic, before this frame is updated\n   */\n  public onPreUpdate(engine: ex.Engine, delta: number) {\n    // update velocity\n    this.vel.setTo(-1, 0)\n  }\n}\n```\n\n### Post-update\n\n[[Actor.onPostUpdate]] is called after [[Actor.update]] to prepare state for the _next_ frame. Things that need to be updated include state, drawing, or position.\n\n<Note>\n\nThis is the recommended method to override for adding update logic to your actors since it runs after Excalibur has done all the update logic for the frame and before things get drawn to the screen.\n\n</Note>\n\n```ts\nclass Player extends Actor {\n  /**\n   * RECOMMENDED: Runs after \"core\" update logic, before the next frame.\n   * Usually this is what you want!\n   */\n  public onPostUpdate(engine: ex.Engine, delta: number) {\n    // check if player died\n    if (this.health <= 0) {\n      this.kill()\n      return\n    }\n  }\n}\n```\n\n## Actor Graphics\n\nActors by default have no associated [graphics](/docs/graphics), meaning that they will be rendered without any graphics unless you've assigned a default [[Actor.color]].\n\nIf an actor has a color set, it will draw a box or circle in that color, if width/height or radius is set.\n\nThis can be useful at the beginning of development when you're just tinkering but for most games you might want to add sprites, animations, and other drawings over simple shapes.\n\n### Working with Images & Sprites\n\nThink of an [[ImageSource]] as the raw image file that will be loaded into Excalibur from a url.\n\nIn order for it to be drawn it must be converted to a [Sprite](/docs/graphics#sprites).\n\n```typescript\nconst image = new ex.ImageSource('./path/to/image.png')\nconst sprite = image.toSprite()\n\nactor.graphics.use(sprite)\n```\n\nA common pattern is to define graphics in the `onInitialize`\n\n```ts\nconst image = new ex.ImageSource('./path/to/player.png')\n\nclass Player extends ex.Actor {\n  public onInitialize(engine: ex.Engine) {\n    // set as the \"default\" drawing\n    this.graphics.use(image.toSprite())\n  }\n}\n```\n\n<Note>\n\n**Important!** Actors have a default anchor of (0.5, 0.5) which means their graphics are positioned in their center (not top-left) by default.\n\n</Note>\n\n## Drawing hooks\n\nLike [the update loop](#updating-actors), the draw loop has hooks you can override to perform custom drawing.\n\nFor drawing hooks the `ExcaliburGraphicsContext` is replacing the browser `CanvasRenderingContext2D`. But if you need to do some custom drawing using the `CanvasRenderingContext2D` the new [`Canvas`](https://excaliburjs.com/docs/api/edge/classes/Canvas.html) graphic has your back.\n\n```typescript\nconst canvas = new ex.Canvas({\n  cache: true, // If true draw once until flagged dirty again, otherwise draw every time\n  draw: (ctx: CanvasRenderingContext2D) => {\n    ctx.fillStyle = 'red'\n    ctx.fillRect(0, 0, 200, 200)\n  },\n})\n\nactor.graphics.use(canvas)\n```\n\nOverride the [[GraphicsComponent.onPreDraw|Actor.graphics.onPreDraw]] or [[GraphicsComponent.onPostDraw|Actor.graphics.onPostDraw]] methods to customize the draw logic at different points in the loop.\n\n<Note>\n\nReference [Actor lifecycle](#actor-lifecycle) for a breakdown of each phase and when things are executed.\n\n</Note>\n\n### Pre-draw\n\n[[GraphicsComponent.onPreDraw|Actor.graphics.onPreDraw]] is run _before_ the core draw logic to prepare the frame.\n\n<Note>\n\n**Important:** This runs _before_ Excalibur has run all its draw logic to apply effects, transform information, etc. so you essentially are working with the _last frame's draw state_.\n\n</Note>\n\n```ts\nclass Player extends ex.Actor {\n  constructor() {\n    /**\n     * ADVANCED: This is run before Actor.graphics.onPreDraw core logic.\n     */\n    this.graphics.onPreDraw = (\n      ctx: ExcaliburGraphicsContext,\n      delta: number\n    ) => {\n      // custom drawing\n    }\n  }\n}\n```\n\n### Post-draw\n\n[[GraphicsComponent.onPostDraw|Actor.graphics.onPostDraw]] is run _after_ the core draw and will draw in the current frame.\n\n<Note>\n\nThis is the recommended method to override since Excalibur has run its core draw logic and you can now customize what gets drawn during the current frame.\n\n</Note>\n\n```ts\nclass Player extends ex.Actor {\n  constructor() {\n    /**\n     * ADVANCED: This is run before Actor.graphics.onPreDraw core logic.\n     */\n    this.graphics.onPostDraw = (\n      ctx: ExcaliburGraphicsContext,\n      delta: number\n    ) => {\n      // custom drawing\n    }\n  }\n}\n```\n\n### Adding actors to the scene\n\nFor an [[Actor]] to be drawn and updated, it needs to be part of the \"scene graph\".\nThe [[Engine]] provides several easy ways to quickly add/remove actors from the\ncurrent scene.\n\n```js\nconst game   = new ex.Engine(...);\nconst player = new ex.Actor();\nconst enemy  = new ex.Actor();\n// add them to the \"root\" scene\ngame.add(player);\ngame.add(enemy);\n// start game\ngame.start();\n```\n\nYou can also add actors to a [[Scene]] instance specifically.\n\n```js\nconst game = new ex.Engine()\nconst level1 = new ex.Scene()\nconst player = new ex.Actor()\nconst enemy = new ex.Actor()\n// add actors to level1\nlevel1.add(player)\nlevel1.add(enemy)\n// add level1 to the game\ngame.add('level1', level1)\n// start the game\ngame.start()\n// after player clicks start game, for example\ngame.goToScene('level1')\n```\n\n## Collision Detection\n\nBy default Actors do not participate in collisions. If you wish to make\nan actor participate, you need to switch from the default [[CollisionType.PreventCollision|prevent collision]]\nto [[CollisionType.Active|active]], [[CollisionType.Fixed|fixed]], or [[CollisionType.Passive|passive]] collision type.\n\n`embed:excalibur-snippets/src/collision/main.ts{snippet: \"collision\"}`\n\n<IFrameEmbed src=\"https://excaliburjs.com/excalibur-snippets/collision/\" />\n\n<Note>\n\nFor more information on collisions, see [Physics](/docs/physics).\n\n</Note>\n","frontmatter":{"path":"/docs/actors","title":"Actors","section":"Fundamentals"}}},"pageContext":{"id":"d76a770e-ba1f-523e-b91e-20478205d36b","frontmatter":{"title":"Actors","path":"/docs/actors","section":"Fundamentals"}}},"staticQueryHashes":["3287062156"],"slicesMap":{}}